options
{
 AA_samples 6
 outputs "RGB RGB myfilter mydriver"
 xres 1200
 yres 800
 GI_diffuse_depth 3
}
  
driver_png
{
 name mydriver
 filename "randflake.png"
}
  
gaussian_filter
{
 name myfilter
}
  
plane
{
 name myplane
 point 0 -10 0
 normal 0 1 0
 shader planeshader
}
  
random_flake
{
 name myrandflake
 shader aiUtility1
 density aiOslShader1
 seed 4
}
  
lambert
{
 name flakeshader
 Kd_color 1.0 0.5 0.4
}
  
lambert
{
 name planeshader
 Kd_color .15 .2 .2
}


polymesh
{
 name pPlaneShape1
 visibility 255
 sidedness 255
 matrix
 106.061165 0 0 0
 0 106.061165 0 0
 0 0 106.061165 0
 0 0 0 1
 shader "mat_floor"
 use_light_group off
 id 141609554
 nsides 100 1 b85UINT
B!%<_l4$$$$=
 vidxs 400 1 b85UINT
B'Rg(<'n6:@(4ZLD(P)^H(kMpL)1r-P)MA?T)heQX*/4c\*JXu`+,LDh+GpVl+c?hp,)d%t,E37x,`WJ'-'&\+-BJn/-]o+3.$>=7.[1a?.vUsC/=%0G/XIBK/smTO0:<fS0U`xW0q05[17TG_1RxYc24l(k2P;:o2k_Ls32.^w3MRq&3hw.*4/F@.4JjR24f9d65,]v:5cQEB6)uWF6EDiJ6`i&N7'88R7B\JV7^+\Z8$On^8?t+b8[C=f9=6an9XZsr9t*0v::NC%:UrU):qAg-;7f$1;S565;nYH9<5(Z=<kq)E=2@;I=MdMM=i3_Q>/WqU>K'.Y>fK@]?,oRa?H>de?cbvi@EVEq@a%WuA'Ij$ABn'(A^=9,B$aK0B@0]4B[To8Bw$,<C=H>@Ct;bHD:_tLDV/1PDqSCTE7wUXESFg\Enk$`F5:6dFP^HhFl-ZlGMv)tGiE;xH/iN'HK8`+Hf\r/I-,/3IHPA7IctS;J*Ce?JEgwC
 nidxs 400 1 b85UINT
B$v2N*$[2`0%XA8:&:4\B&q(+J'RpOR(4csZ(kWBb)MJfj*/>5r+G^)V+,U5Y+c?Sa,)chg,E3(m,`W=s-'&S$-BJh*-]o(0.$>=6.vCa?.[:jA/=%0G/XIBK/smTO0:<fS0U`xW0q05[17TG_1RxYc2P)(k24u1m2k_Ls32.^w3MRq&3hw.*4/F@.4JjR24f9d65,]v:6)cEB5cZND6EDiJ6`i&N7'88R7B\JV7^+\Z8$On^8?t+b8[C=f9XHan9=?jp9t*0v::NC%:UrU):qAg-;7f$1;S565;nYH9<5(Z==2.)E<l%2G=MdMM=i3_Q>/WqU>K'.Y>fK@]?,oRa?H>de?cbvi@`hEq@E_NsA'Ij$ABn'(A^=9,B$aK0B@0]4B[To8Bw$,<C=H>@D:MbHCtDkJDV/1PDqSCTE7wUXESFg\Enk$`F5:6dFP^HhFl-ZlGi3)tGN*2vH/iN'HK8`+Hf\r/I-,/3IHPA7IctS;J*Ce?JEgwC
 uvidxs 400 1 b85UINT
B'Rg(<'n6:@(4ZLD(P)^H(kMpL)1r-P)MA?T)heQX*/4c\*JXu`+,LDh+GpVl+c?hp,)d%t,E37x,`WJ'-'&\+-BJn/-]o+3.$>=7.[1a?.vUsC/=%0G/XIBK/smTO0:<fS0U`xW0q05[17TG_1RxYc24l(k2P;:o2k_Ls32.^w3MRq&3hw.*4/F@.4JjR24f9d65,]v:5cQEB6)uWF6EDiJ6`i&N7'88R7B\JV7^+\Z8$On^8?t+b8[C=f9=6an9XZsr9t*0v::NC%:UrU):qAg-;7f$1;S565;nYH9<5(Z=<kq)E=2@;I=MdMM=i3_Q>/WqU>K'.Y>fK@]?,oRa?H>de?cbvi@EVEq@a%WuA'Ij$ABn'(A^=9,B$aK0B@0]4B[To8Bw$,<C=H>@Ct;bHD:_tLDV/1PDqSCTE7wUXESFg\Enk$`F5:6dFP^HhFl-ZlGMv)tGiE;xH/iN'HK8`+Hf\r/I-,/3IHPA7IctS;J*Ce?JEgwC
 vlist 121 1 b85VECTOR
aDq99Y&XMt89+]ca?IjJY&XMt89+]ca9wF[Y&XMt89+]ca1fesY&XMt89+]ca$.aHY&XMt89+]czY&XMt89+]c7m>0vY&XMt89+]c8%v5HY&XMt89+]c8.1k0Y&XMt89+]c83Y9uY&XMt89+]c89+]cY&XMt89+]caDq99Xv1*083Y9ta?IjJXv1*083Y9ta9wF[Xv1*083Y9ta1fesXv1*083Y9ta$.aHXv1*083Y9tzXv1*083Y9t7m>0vXv1*083Y9t8%v5HXv1*083Y9t8.1k0Xv1*083Y9t83Y9uXv1*083Y9t89+]cXv1*083Y9taDq99Xp^[A8.1k0a?IjJXp^[A8.1k0a9wF[Xp^[A8.1k0a1fesXp^[A8.1k0a$.aHXp^[A8.1k0zXp^[A8.1k07m>0vXp^[A8.1k08%v5HXp^[A8.1k08.1k0Xp^[A8.1k083Y9uXp^[A8.1k089+]cXp^[A8.1k0aDq99XhN%Y8%v5Ha?IjJXhN%Y8%v5Ha9wF[XhN%Y8%v5Ha1fesXhN%Y8%v5Ha$.aHXhN%Y8%v5HzXhN%Y8%v5H7m>0vXhN%Y8%v5H8%v5HXhN%Y8%v5H8.1k0XhN%Y8%v5H83Y9uXhN%Y8%v5H89+]cXhN%Y8%v5HaDq99XZjv.7m>0ra?IjJXZjv.7m>0ra9wF[XZjv.7m>0ra1fesXZjv.7m>0ra$.aHXZjv.7m>0rzXZjv.7m>0r7m>0vXZjv.7m>0r8%v5HXZjv.7m>0r8.1k0XZjv.7m>0r83Y9uXZjv.7m>0r89+]cXZjv.7m>0raDq99zza?IjJzza9wF[zza1feszza$.aH!$$$$$$$$$)7m>0vzz8%v5Hzz8.1k0zz83Y9uzz89+]czzaDq99/O%E\a$.aLa?IjJ/O%E\a$.aLa9wF[/O%E\a$.aLa1fes/O%E\a$.aLa$.aH/O%E\a$.aLz/O%E\a$.aL7m>0v/O%E\a$.aL8%v5H/O%E\a$.aL8.1k0/O%E\a$.aL83Y9u/O%E\a$.aL89+]c/O%E\a$.aLaDq99/\]J.a1fesa?IjJ/\]J.a1fesa9wF[/\]J.a1fesa1fes/\]J.a1fesa$.aH/\]J.a1fesz/\]J.a1fes7m>0v/\]J.a1fes8%v5H/\]J.a1fes8.1k0/\]J.a1fes83Y9u/\]J.a1fes89+]c/\]J.a1fesaDq99/dn*ka9wF[a?IjJ/dn*ka9wF[a9wF[/dn*ka9wF[a1fes/dn*ka9wF[a$.aH/dn*ka9wF[z/dn*ka9wF[7m>0v/dn*ka9wF[8%v5H/dn*ka9wF[8.1k0/dn*ka9wF[83Y9u/dn*ka9wF[89+]c/dn*ka9wF[aDq99/j@N[a?IjKa?IjJ/j@N[a?IjKa9wF[/j@N[a?IjKa1fes/j@N[a?IjKa$.aH/j@N[a?IjKz/j@N[a?IjK7m>0v/j@N[a?IjK8%v5H/j@N[a?IjK8.1k0/j@N[a?IjK83Y9u/j@N[a?IjK89+]c/j@N[a?IjKaDq99/ogrIaDq99a?IjJ/ogrIaDq99a9wF[/ogrIaDq99a1fes/ogrIaDq99a$.aH/ogrIaDq99z/ogrIaDq997m>0v/ogrIaDq998%v5H/ogrIaDq998.1k0/ogrIaDq9983Y9u/ogrIaDq9989+]c/ogrIaDq99
 nlist 121 1 b85VECTOR
zy0(Jvtzy0(Jvszy0(Jvtzy0(Jvuz8Fcb80(Jvoz8Fcb80(Jvozy0(Jvszy0(Jvtzy0(Jvszy0(Jvtzy0(Jvszy0(Jvszy0(Jvszy0(Jvtzy0(Jvszy0(Jvtz8Fcb80(Jvsz8Fcb80(Jvszy0(Jvszy0(Jvtzy0(Jvtzy0(Jvvzy0(Jvuzy0(Jvvz8Fcb80(Jvsz8Fcb80(Jvszy0(Jvuz8Fcb80(Jvuzy0(Jvtzy0(Jvtz8Fcb80(Jvszy0(Jvtzy0(Jvuzy0(Jvtzy0(Jvuz8Fcb80(Jvsz8Fcb80(Jvszy0(Jvtz8Fcb80(Jvszy0(Jvtz8Fcb80(Jvsz8Fcb80(Jvszy0(Jvtzy0(Jvtzy0(Jvtzy0(Jvuz8Fcb80(Jvozy0(Jvtzy0(Jvtzy0(Jvtzy0(Jvtzy0(Jvtz8Fcb80(Jvszy0(Jvtzy0(Jvvzy0(Jvtzy0(Jvuz8Fcb80(Jvqz8Fcb80(Jvszy0(Jvtz8Fcb80(Jvszy0(Jvtzy0(Jvtz8Fcb80(Jvszy0(Jvtzy0(Jvuzy0(Jvtzy0(Jvuz8Fcb80(Jvqz8Fcb80(Jvqzy0(Jvtz8Fcb80(Jvszy0(Jvtzy0(Jvtz8Fcb80(Jvszy0(Jvtzy0(Jvtzy0(Jvtzy0(Jvuzy0(Jvtz8Fcb80(Jvszy0(Jvtz8Fcb80(Jvszy0(Jvtzy0(Jvtz8Fcb80(Jvszy0(Jvtzy0(Jvsz8Fcb80(Jvuz8Fcb80(Jvuz8Fcb80(Jvsz8Fcb80(Jvsz8Fcb80(Jvuz8Fcb80(Jvsz8Fcb80(Jvsz8Fcb80(Jvsz8Fcb80(Jvsz8Fcb80(Jvszy0(Jvtzy0(Jvtzy0(Jvuz8Fcb80(Jvqz8Fcb80(Jvqzy0(Jvsz8Fcb80(Jvqzy0(Jvtzy0(Jvtz8Fcb80(Jvszy0(Jvtzy0(Jvtzy0(Jvqzy0(Jvtzy0(Jvszy0(Jvszy0(Jvozy0(Jvqzy0(Jvtzy0(Jvuzy0(Jvtzy0(Jvtzy0(Jvt
 uvlist 121 1 b85VECTOR2
zz7m>0sz8%v5Iz8.1k0z83Y9tz89+]cz8;io[z8>S,Rz8A<>Jz8D%PBzyzz!7m>0s$$$$'8%v5I7m>0s8.1k07m>0s83Y9t7m>0s89+]c7m>0s8;io[7m>0s8>S,R7m>0s8A<>J7m>0s8D%PB7m>0sy7m>0sz8%v5I7m>0s!8%v5I$$$$'8.1k08%v5I83Y9t8%v5I89+]c8%v5I8;io[8%v5I8>S,R8%v5I8A<>J8%v5I8D%PB8%v5Iy8%v5Iz8.1k07m>0s8.1k08%v5I!8.1k0$$$$'83Y9t8.1k089+]c8.1k08;io[8.1k08>S,R8.1k08A<>J8.1k08D%PB8.1k0y8.1k0z83Y9t7m>0s83Y9t8%v5I83Y9t8.1k0!83Y9t$$$$'89+]c83Y9t8;io[83Y9t8>S,R83Y9t8A<>J83Y9t8D%PB83Y9ty83Y9tz89+]c7m>0s89+]c8%v5I89+]c8.1k089+]c83Y9t89+]c89+]c89+]c8;io[89+]c8>S,R89+]c8A<>J89+]c8D%PB89+]cy89+]cz8;io[7m>0s8;io[8%v5I8;io[8.1k08;io[83Y9t8;io[89+]c!8;io[$$$$'8>S,R8;io[8A<>J8;io[8D%PB8;io[y8;io[z8>S,R7m>0s8>S,R8%v5I8>S,R8.1k08>S,R83Y9t8>S,R89+]c8>S,R8;io[!8>S,R$$$$'8A<>J8>S,R8D%PB8>S,Ry8>S,Rz8A<>J7m>0s8A<>J8%v5I8A<>J8.1k08A<>J83Y9t8A<>J89+]c8A<>J8;io[8A<>J8>S,R!8A<>J$$$$'8D%PB8A<>Jy8A<>Jz8D%PB7m>0s8D%PB8%v5I8D%PB8.1k08D%PB83Y9t8D%PB89+]c8D%PB8;io[8D%PB8>S,R8D%PB8A<>J!8D%PB$$$$'y8D%PBzy7m>0sy8%v5Iy8.1k0y83Y9ty89+]cy8;io[y8>S,Ry8A<>Jy8D%PB!8Fcb9$$$$'
 smoothing on
 step_size 0
 volume_padding 0
 declare maya_full_name constant STRING
 maya_full_name "|pPlane1|pPlaneShape1"
}


persp_camera
{
 name perspShape
 matrix
 0.91775465 2.77555756e-17 0.397147894 0
 0.314959913 0.609150708 -0.727829397 0
 -0.241922915 0.793054461 0.559050858 0
 -4.81647778 15.723938 11.2633486 1
 near_clip 0.100000001
 far_clip 10000
 screen_window_min -1 -1
 screen_window_max 1 1
 shutter_start 0
 shutter_end 0
 shutter_type "box"
 rolling_shutter "off"
 rolling_shutter_duration 0
 motion_start 0
 motion_end 0
 exposure 0
 fov 54.4322243
 uv_remap 0 0 0 1
 declare maya_full_name constant STRING
 maya_full_name "|persp|perspShape"
}

skydome_light
{
 name aiSkyDomeLightShape1
 matrix
 1 0 0 0
 0 1 0 0
 0 0 1 0
 0 0 0 1
 color aiPhysicalSky1
 intensity 4
 exposure 0
 cast_shadows on
 cast_volumetric_shadows on
 shadow_density 1
 shadow_color 0 0 0
 samples 1
 normalize on
 camera 1
 transmission 1
 diffuse 1
 specular 1
 sss 1
 indirect 1
 max_bounces 999
 volume_samples 2
 volume 1
 aov "default"
 resolution 1000
 format "latlong"
 portal_mode "interior_only"
 aov_indirect off
 declare maya_full_name constant STRING
 maya_full_name "|aiSkyDomeLight1|aiSkyDomeLightShape1"
}


standard_surface
{
 name mat_floor
 base 1
 base_color 0.0324675329 0.0324675329 0.0324675329
 specular 0
}

physical_sky
{
 name aiPhysicalSky1
 ground_albedo 0.100000001 0.100000001 0.100000001
 elevation 21.6867466
 azimuth 312.289154
 sun_direction 0 1 0
 sun_size 0.400000006
 sun_tint 1 1 1
 sky_tint 1 1 1
 X 1 0 0
 Y 0 1 0
 Z 0 0 1
}

utility
{
 name aiUtility1
 shade_mode "plastic"
 color 0.915000021 0.0978000015 0.0118000004
 roughness 0.234939754
}



osl
{
 name aiOslShader1
 code "    float smin2(float a, float b, float r)
    {
    float f = max(0., 1. - abs(b - a)/r);
    return min(a, b) - r*.25*f*f;
    }



    vector hash( vector x )
    {
        vector a = vector( dot(x,vector(127.1, 311.7, 74.7)),
                        dot(x,vector(269.5, 183.3, 246.1)),
                        dot(x,vector(113.5, 271.9, 124.6)) );
        
        vector result = sin(a)*43758.5453123;
        return result - floor(result);
    }



    float voronoi_smoothed(vector x, float smoothing){


        vector p = floor(x);
        vector f = x - floor(x);
        vector h = step(0.5, f) - 2.0;
        p += h; f -= h;
        
        // Voronoi cell ID containing the minimum offset point distance. The nearest
        // edge will be one of the cells edges.
        vector minCellID = vector(0); // Redundant initialization, but I've done it anyway.


        // First pass: Regular Voronoi.
        vector mo;
        
        // Minimum distance, \"smooth\" distance to the nearest cell edge, regular
        // distance to the nearest cell edge, and a line distance place holder.
        float md = 8.0, lMd = 8.0, lnDist, d;
        
        for( int k=0; k<=3; k++ )
        for( int j=0; j<=3; j++ )
        for( int i=0; i<=3; i++ )
        {
            vector b = vector(float(i), float(j), float(k));
            vector r = vector( b ) - f + hash( p + b );
            
            // Determine the distance metric to the point.
            d = dot(r, r);
            if( d<md ){ // Perform updates, if applicable.    
                md = d;  // Update the minimum distance.
                // Keep note of the position of the nearest cell point - with respect
                // to \"p,\" of course. It will be used in the second pass.
                mo = r; 
                //cellID = h + p; // For cell coloring.


                // zeno: how should mincellid be used??
                minCellID = b; // Record the minimum distance cell ID.
            }
        }
        
        // Second pass: Point to nearest cell-edge distance.
        //
        // With the ID of the cell containing the closest point, do a sweep of all the
        // surrounding cell edges to determine the closest one. You do that by applying
        // a standard distance to a line formula.
        for( int k=0; k<=3; k++ )
        for( int j=0; j<=3; j++ )
        for( int i=0; i<=3; i++ )
        {
            vector b = vector(float(i), float(j), float(k));
        
            // Determine the offset hexagonal point in relation to the minimum cell offset.
            //vec2 r = hexPt(pH + gridpoint + minCellID) - x - mo; // Note the \"-mo\" to save some operations. 
            vector r = vector( b ) - f + hash( p + b ) - mo;
            
            // Skip the same cell.
            if(dot(r, r)>.00001){
                
                // This tiny line is the crux of the whole example, believe it or not. Basically, it's
                // a bit of simple trigonometry to determine the distance from the cell point to the
                // cell border line. See IQ's article (link above) for a visual representation.            
                lnDist = dot(mo + r*.5, normalize(r));
                
                // Abje's addition. Border distance using a smooth minimum. Insightful, and simple.
                //
                // On a side note, IQ reminded me that the order in which the polynomial-based smooth
                // minimum is applied effects the result. However, the exponentional-based smooth
                // minimum is associative and commutative, so is more correct. In this particular case, 
                // the effects appear to be negligible, so I'm sticking with the cheaper polynomial-based
                // smooth minimum, but it's something you should keep in mind. By the way, feel free to 
                // uncomment the exponential one and try it out to see if you notice a difference.
                //
                // Polynomial-based smooth minimum. The last factor controls the roundness of the 
                // edge joins. Zero gives you sharp joins, and something like \".25\" will produce a
                // more rounded look. Tomkh noticed that a variable smoothing factor - based on the
                // line distance - produces continuous isolines.
                lMd = smin2(lMd, lnDist, (lnDist*.5 + .5)*smoothing);
                
            }
        }


        // Return the smoothed and unsmoothed distance. I think they need capping at zero... but I'm not 
        // positive. Although not used here, the standard minimum point distance is returned also.
        return max(lMd, 0.0);    
    }



    float remap(vector p, float smoothing, float ew){    
        float c = voronoi_smoothed(p, smoothing);
        
        if(c < ew){ 
            c = abs(c - ew)/ew; // Normalize the domain to a range of zero to one.
            c = smoothstep(0.03, 0.1, c);
        }
        else { // Over the threshold? Use the regular Voronoi cell value.
            c = (c - ew)/(1. - ew); // Normalize the domain to a range of zero to one.
            c = smoothstep(1.0, 1.0, c);
        }
        
        return c;
    }



    shader voronoi_smooth(
            point pos = P,
            vector scale = vector(1.0),


            float border_thickness = 0.025,
            float smoothing = 0.35,


            output color Color = color(0.0) )
    {
        Color = color(remap(pos * scale, smoothing, border_thickness));
    }
"
}